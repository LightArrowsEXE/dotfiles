{
  "Randomise Grain": {
    "command": "local function parse_and_randomize(line, char_list)\n    -- Replace each non-escaped character with a random one from the list\n    local new_line_chars = {}\n    local i = 1\n    while i <= #line do\n        local char = line:sub(i, i)\n        if char == \"\\\\\" and i < #line then\n            table.insert(new_line_chars, line:sub(i, i + 1))\n            i = i + 2\n        elseif char == \"%\" then\n            local random_char = char_list[math.random(#char_list)]\n            table.insert(new_line_chars, random_char)\n            i = i + 2\n        elseif char:match(\"%S\") then\n            local random_char = char_list[math.random(#char_list)]\n            table.insert(new_line_chars, random_char)\n            i = i + 1\n        else\n            table.insert(new_line_chars, \" \")\n            i = i + 1\n        end\n    end\n\n    return table.concat(new_line_chars)\nend\n\n-- Define the character list\nlocal char_list = {\n    'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'x', 'w', 'z',\n    'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'X', 'W', 'Z',\n    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\n    '!', '\\\"', '\\'', ',', '%.', ':', ';', '%?'\n}\n\nfor _, li in ipairs(sel) do\n   local line = sub[li]\n   local og_text = line.text:gsub(\"{.-}\", \"\"):gsub(\"([%^%$%(%)%%%.%[%]%*%+%-%?])\", \"%%%1\")\n   local new_text = parse_and_randomize(og_text, char_list)\n   local new_line = line.text:gsub(og_text, new_text)\n   line.text = new_line\n   sub[li] = line\nend",
    "language": "Lua"
  },
  "Round to Precision": {
    "command": "export script_name = \"Round to Precision\"\nexport script_description = \"Rounds all tags to their (shortest) precision\"\nexport script_version = \"0.0.1\"\nexport script_author = \"witchymary\"\nexport script_namespace = \"witchymary.RoundToPrecision\"\n\nDependencyControl = require \"l0.DependencyControl\"\ndepctrl = DependencyControl{\n  {\n    {\"a-mo.LineCollection\", version: \"1.3.0\", url: \"https://github.com/TypesettingTools/Aegisub-Motion\",\n      feed: \"https://raw.githubusercontent.com/TypesettingTools/Aegisub-Motion/DepCtrl/DependencyControl.json\"},\n    {\"l0.ASSFoundation\", version: \"0.4.0\", url: \"https://github.com/TypesettingTools/ASSFoundation\",\n      feed: \"https://raw.githubusercontent.com/TypesettingTools/ASSFoundation/master/DependencyControl.json\"}\n  }\n}\nLineCollection, ASS = depctrl\\requireModules!\nlogger = depctrl\\getLogger!\n\n\nround_to_decimal = (n, d) ->\n    mult = 10^d\n    if n >= 0\n        math.floor(n * mult + 0.5) / mult\n    else\n        math.ceil(n * mult + 0.5) / mult\n\ncalculate_precision = (precision, value, shortest) ->\n    -- Parse and validate inputs\n    precision = tonumber precision\n    unless precision\n        logger\\fatal \"Invalid precision: must be a numeric value.\"\n\n    value = tonumber value\n    unless value\n        logger\\fatal \"Invalid value: must be a numeric value.\"\n\n    return value if value % 1 == 0\n\n    is_negative = false\n    if value < 0\n        value = value * -1\n        is_negative = true\n    \n    -- Round to nearest precision multiple\n    rounded_value = math.floor(value / precision + 0.5) * precision\n\n    return rounded_value unless shortest\n            \n    -- Calculate precision boundaries\n    half_precision = precision / 2\n    lower_bound = rounded_value - half_precision\n    upper_bound = rounded_value + half_precision\n\n    for d = 0, 10\n        candidate = round_to_decimal rounded_value, d\n        if candidate >= lower_bound and candidate < upper_bound\n            unless is_negative\n                return candidate\n            else\n                return candidate * -1\n\n    -- Fallback with 3 decimal places\n    unless is_negative\n        round_to_decimal rounded_value, 3\n    else\n        round_to_decimal(rounded_value, 3) * -1\n\n\nparse_tags = (tags) ->\n    {\n        position: unless tags.position then false else do\n            x, y = tags.position\\getTagParams!\n            { :x, :y }\n        origin: unless tags.origin then false else do\n            x, y = tags.origin\\getTagParams!\n            { :x, :y }\n        move: unless tags.move then false else do\n            x1, y1, x2, y2 = tags.move\\getTagParams!\n            { :x1, :y1, :x2, :y2 }\n        clip_rect: unless tags.clip_rect then false else\n            x1, y1, x2, y2 = tags.clip_rect\\getTagParams!\n            { :x1, :y1, :x2, :y2 }\n        iclip_rect: unless tags.iclip_rect then false else\n            x1, y1, x2, y2 = tags.iclip_rect\\getTagParams!\n            { :x1, :y1, :x2, :y2 }\n        clip_vect: unless tags.clip_vect then false else\n            [ pos for pos in tags.clip_vect\\getTagParams!\\gmatch \"%S+\" ]\n        iclip_vect: unless tags.iclip_vect then false else\n            [ pos for pos in tags.iclip_vect\\getTagParams!\\gmatch \"%S+\" ]\n    }\n\n\nmain = (sub, sel) ->\n    lines = LineCollection sub, sel\n    return if #lines.lines == 0\n    lines\\runCallback (lines, line, i) ->\n        data = ASS\\parse line\n        tags = (data\\getEffectiveTags 1, false, true, false).tags\n        parsed_tags = parse_tags tags\n        \n        calc_tag = (tag, precision = 0.125) ->\n            { pos,calculate_precision precision,value,true for pos,value in pairs tag }\n\n        calc_shape = (shape) ->\n            shape_table = { }\n            for _, pos in ipairs shape\n                if tonumber pos\n                    table.insert shape_table, calculate_precision 0.125,pos,true \n                else\n                    table.insert shape_table, pos\n            table.concat shape_table, \" \"\n\n        if parsed_tags.position\n            position = calc_tag parsed_tags.position\n            tags.position\\set position.x, position.y\n  \n        if parsed_tags.move\n            og_move = { tags.move\\getTagParams! }\n            move = calc_tag parsed_tags.move\n            tags.move\\set move.x1, move.y1, move.x2, move.y2, og_move[5], og_move[6]\n  \n        if parsed_tags.origin\n            origin = calc_tag parsed_tags.origin\n            tags.origin\\set origin.x, origin.y\n\n        if parsed_tags.clip_vect\n            clip = calc_shape parsed_tags.clip_vect\n            clip = ASS.Draw.DrawingBase(ASS.Parser.Drawing\\getContours clip)\n            data\\replaceTags { ASS\\createTag 'clip_vect', clip }\n\n        if parsed_tags.iclip_vect\n            iclip = calc_shape parsed_tags.iclip_vect\n            iclip = ASS.Draw.DrawingBase(ASS.Parser.Drawing\\getContours iclip)\n            data\\replaceTags { ASS\\createTag 'iclip_vect', iclip }\n\n        if parsed_tags.clip_rect\n            clip = calc_tag parsed_tags.clip_rect, 1\n            tags.clip_rect\\set clip.x1, clip.y1, clip.x2, clip.y2\n    \n        if parsed_tags.iclip_rect\n            iclip = calc_tag parsed_tags.iclip_rect, 1\n            tags.iclip_rect\\set iclip.x1, iclip.y1, iclip.x2, iclip.y2\n\n        data\\callback ((section) ->\n            drawing = [ pos for pos in section\\getTagParams!\\gmatch \"%S+\" ]\n            drawing = calc_shape drawing\n            drawing = ASS.Section.Drawing(ASS.Parser.Drawing\\getContours drawing, 1)\n            drawing\n        ), ASS.Section.Drawing, 1\n\n        aegisub.progress.set (i/#lines)*100\n        aegisub.progress.task \"Processing lines #{i}/#{#lines}\"\n              \n        data\\commit!\n    lines\\replaceLines!\n\nmain sub,sel",
    "language": "MoonScript"
  }
}